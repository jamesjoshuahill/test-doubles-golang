// generated by "charlatan repository logger".  DO NOT EDIT.

package charlatan

import "reflect"

// repositoryQueryInvocation represents a single call of Fakerepository.Query
type repositoryQueryInvocation struct {
	Parameters struct {
		Name     string
		Category string
	}
	Results struct {
		Ident1 []Record
		Ident2 error
	}
}

// NewrepositoryQueryInvocation creates a new instance of repositoryQueryInvocation
func NewrepositoryQueryInvocation(name string, category string, ident1 []Record, ident2 error) *repositoryQueryInvocation {
	invocation := new(repositoryQueryInvocation)

	invocation.Parameters.Name = name
	invocation.Parameters.Category = category

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return invocation
}

// repositoryTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type repositoryTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
Fakerepository is a mock implementation of repository for testing.
Use it in your tests as in this example:

	package example

	func TestWithrepository(t *testing.T) {
		f := &charlatan.Fakerepository{
			QueryHook: func(name string, category string) (ident1 []Record, ident2 error) {
				// ensure parameters meet expectations, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeQuery ...
		f.AssertQueryCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeQuery.
*/
type Fakerepository struct {
	QueryHook func(string, string) ([]Record, error)

	QueryCalls []*repositoryQueryInvocation
}

// NewFakerepositoryDefaultPanic returns an instance of Fakerepository with all hooks configured to panic
func NewFakerepositoryDefaultPanic() *Fakerepository {
	return &Fakerepository{
		QueryHook: func(string, string) (ident1 []Record, ident2 error) {
			panic("Unexpected call to repository.Query")
		},
	}
}

// NewFakerepositoryDefaultFatal returns an instance of Fakerepository with all hooks configured to call t.Fatal
func NewFakerepositoryDefaultFatal(t_sym1 repositoryTestingT) *Fakerepository {
	return &Fakerepository{
		QueryHook: func(string, string) (ident1 []Record, ident2 error) {
			t_sym1.Fatal("Unexpected call to repository.Query")
			return
		},
	}
}

// NewFakerepositoryDefaultError returns an instance of Fakerepository with all hooks configured to call t.Error
func NewFakerepositoryDefaultError(t_sym2 repositoryTestingT) *Fakerepository {
	return &Fakerepository{
		QueryHook: func(string, string) (ident1 []Record, ident2 error) {
			t_sym2.Error("Unexpected call to repository.Query")
			return
		},
	}
}

func (f *Fakerepository) Reset() {
	f.QueryCalls = []*repositoryQueryInvocation{}
}

func (f_sym3 *Fakerepository) Query(name string, category string) (ident1 []Record, ident2 error) {
	if f_sym3.QueryHook == nil {
		panic("repository.Query() called but Fakerepository.QueryHook is nil")
	}

	invocation_sym3 := new(repositoryQueryInvocation)
	f_sym3.QueryCalls = append(f_sym3.QueryCalls, invocation_sym3)

	invocation_sym3.Parameters.Name = name
	invocation_sym3.Parameters.Category = category

	ident1, ident2 = f_sym3.QueryHook(name, category)

	invocation_sym3.Results.Ident1 = ident1
	invocation_sym3.Results.Ident2 = ident2

	return
}

// SetQueryStub configures repository.Query to always return the given values
func (f_sym4 *Fakerepository) SetQueryStub(ident1 []Record, ident2 error) {
	f_sym4.QueryHook = func(string, string) ([]Record, error) {
		return ident1, ident2
	}
}

// SetQueryInvocation configures repository.Query to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym5 *Fakerepository) SetQueryInvocation(calls_sym5 []*repositoryQueryInvocation, fallback_sym5 func() ([]Record, error)) {
	f_sym5.QueryHook = func(name string, category string) (ident1 []Record, ident2 error) {
		for _, call_sym5 := range calls_sym5 {
			if reflect.DeepEqual(call_sym5.Parameters.Name, name) && reflect.DeepEqual(call_sym5.Parameters.Category, category) {
				ident1 = call_sym5.Results.Ident1
				ident2 = call_sym5.Results.Ident2

				return
			}
		}

		return fallback_sym5()
	}
}

// QueryCalled returns true if Fakerepository.Query was called
func (f *Fakerepository) QueryCalled() bool {
	return len(f.QueryCalls) != 0
}

// AssertQueryCalled calls t.Error if Fakerepository.Query was not called
func (f *Fakerepository) AssertQueryCalled(t repositoryTestingT) {
	t.Helper()
	if len(f.QueryCalls) == 0 {
		t.Error("Fakerepository.Query not called, expected at least one")
	}
}

// QueryNotCalled returns true if Fakerepository.Query was not called
func (f *Fakerepository) QueryNotCalled() bool {
	return len(f.QueryCalls) == 0
}

// AssertQueryNotCalled calls t.Error if Fakerepository.Query was called
func (f *Fakerepository) AssertQueryNotCalled(t repositoryTestingT) {
	t.Helper()
	if len(f.QueryCalls) != 0 {
		t.Error("Fakerepository.Query called, expected none")
	}
}

// QueryCalledOnce returns true if Fakerepository.Query was called exactly once
func (f *Fakerepository) QueryCalledOnce() bool {
	return len(f.QueryCalls) == 1
}

// AssertQueryCalledOnce calls t.Error if Fakerepository.Query was not called exactly once
func (f *Fakerepository) AssertQueryCalledOnce(t repositoryTestingT) {
	t.Helper()
	if len(f.QueryCalls) != 1 {
		t.Errorf("Fakerepository.Query called %d times, expected 1", len(f.QueryCalls))
	}
}

// QueryCalledN returns true if Fakerepository.Query was called at least n times
func (f *Fakerepository) QueryCalledN(n int) bool {
	return len(f.QueryCalls) >= n
}

// AssertQueryCalledN calls t.Error if Fakerepository.Query was called less than n times
func (f *Fakerepository) AssertQueryCalledN(t repositoryTestingT, n int) {
	t.Helper()
	if len(f.QueryCalls) < n {
		t.Errorf("Fakerepository.Query called %d times, expected >= %d", len(f.QueryCalls), n)
	}
}

// QueryCalledWith returns true if Fakerepository.Query was called with the given values
func (f_sym6 *Fakerepository) QueryCalledWith(name string, category string) bool {
	for _, call_sym6 := range f_sym6.QueryCalls {
		if reflect.DeepEqual(call_sym6.Parameters.Name, name) && reflect.DeepEqual(call_sym6.Parameters.Category, category) {
			return true
		}
	}

	return false
}

// AssertQueryCalledWith calls t.Error if Fakerepository.Query was not called with the given values
func (f_sym7 *Fakerepository) AssertQueryCalledWith(t repositoryTestingT, name string, category string) {
	t.Helper()
	var found_sym7 bool
	for _, call_sym7 := range f_sym7.QueryCalls {
		if reflect.DeepEqual(call_sym7.Parameters.Name, name) && reflect.DeepEqual(call_sym7.Parameters.Category, category) {
			found_sym7 = true
			break
		}
	}

	if !found_sym7 {
		t.Error("Fakerepository.Query not called with expected parameters")
	}
}

// QueryCalledOnceWith returns true if Fakerepository.Query was called exactly once with the given values
func (f_sym8 *Fakerepository) QueryCalledOnceWith(name string, category string) bool {
	var count_sym8 int
	for _, call_sym8 := range f_sym8.QueryCalls {
		if reflect.DeepEqual(call_sym8.Parameters.Name, name) && reflect.DeepEqual(call_sym8.Parameters.Category, category) {
			count_sym8++
		}
	}

	return count_sym8 == 1
}

// AssertQueryCalledOnceWith calls t.Error if Fakerepository.Query was not called exactly once with the given values
func (f_sym9 *Fakerepository) AssertQueryCalledOnceWith(t repositoryTestingT, name string, category string) {
	t.Helper()
	var count_sym9 int
	for _, call_sym9 := range f_sym9.QueryCalls {
		if reflect.DeepEqual(call_sym9.Parameters.Name, name) && reflect.DeepEqual(call_sym9.Parameters.Category, category) {
			count_sym9++
		}
	}

	if count_sym9 != 1 {
		t.Errorf("Fakerepository.Query called %d times with expected parameters, expected one", count_sym9)
	}
}

// QueryResultsForCall returns the result values for the first call to Fakerepository.Query with the given values
func (f_sym10 *Fakerepository) QueryResultsForCall(name string, category string) (ident1 []Record, ident2 error, found_sym10 bool) {
	for _, call_sym10 := range f_sym10.QueryCalls {
		if reflect.DeepEqual(call_sym10.Parameters.Name, name) && reflect.DeepEqual(call_sym10.Parameters.Category, category) {
			ident1 = call_sym10.Results.Ident1
			ident2 = call_sym10.Results.Ident2
			found_sym10 = true
			break
		}
	}

	return
}

// loggerInfoInvocation represents a single call of Fakelogger.Info
type loggerInfoInvocation struct {
	Parameters struct {
		Msg string
	}
}

// loggerTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type loggerTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
Fakelogger is a mock implementation of logger for testing.
Use it in your tests as in this example:

	package example

	func TestWithlogger(t *testing.T) {
		f := &charlatan.Fakelogger{
			InfoHook: func(msg string) () {
				// ensure parameters meet expectations, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeInfo ...
		f.AssertInfoCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeInfo.
*/
type Fakelogger struct {
	InfoHook func(string)

	InfoCalls []*loggerInfoInvocation
}

// NewFakeloggerDefaultPanic returns an instance of Fakelogger with all hooks configured to panic
func NewFakeloggerDefaultPanic() *Fakelogger {
	return &Fakelogger{
		InfoHook: func(string) {
			panic("Unexpected call to logger.Info")
		},
	}
}

// NewFakeloggerDefaultFatal returns an instance of Fakelogger with all hooks configured to call t.Fatal
func NewFakeloggerDefaultFatal(t_sym11 loggerTestingT) *Fakelogger {
	return &Fakelogger{
		InfoHook: func(string) {
			t_sym11.Fatal("Unexpected call to logger.Info")
			return
		},
	}
}

// NewFakeloggerDefaultError returns an instance of Fakelogger with all hooks configured to call t.Error
func NewFakeloggerDefaultError(t_sym12 loggerTestingT) *Fakelogger {
	return &Fakelogger{
		InfoHook: func(string) {
			t_sym12.Error("Unexpected call to logger.Info")
			return
		},
	}
}

func (f *Fakelogger) Reset() {
	f.InfoCalls = []*loggerInfoInvocation{}
}

func (f_sym13 *Fakelogger) Info(msg string) {
	if f_sym13.InfoHook == nil {
		panic("logger.Info() called but Fakelogger.InfoHook is nil")
	}

	invocation_sym13 := new(loggerInfoInvocation)
	f_sym13.InfoCalls = append(f_sym13.InfoCalls, invocation_sym13)

	invocation_sym13.Parameters.Msg = msg

	f_sym13.InfoHook(msg)

	return
}

// InfoCalled returns true if Fakelogger.Info was called
func (f *Fakelogger) InfoCalled() bool {
	return len(f.InfoCalls) != 0
}

// AssertInfoCalled calls t.Error if Fakelogger.Info was not called
func (f *Fakelogger) AssertInfoCalled(t loggerTestingT) {
	t.Helper()
	if len(f.InfoCalls) == 0 {
		t.Error("Fakelogger.Info not called, expected at least one")
	}
}

// InfoNotCalled returns true if Fakelogger.Info was not called
func (f *Fakelogger) InfoNotCalled() bool {
	return len(f.InfoCalls) == 0
}

// AssertInfoNotCalled calls t.Error if Fakelogger.Info was called
func (f *Fakelogger) AssertInfoNotCalled(t loggerTestingT) {
	t.Helper()
	if len(f.InfoCalls) != 0 {
		t.Error("Fakelogger.Info called, expected none")
	}
}

// InfoCalledOnce returns true if Fakelogger.Info was called exactly once
func (f *Fakelogger) InfoCalledOnce() bool {
	return len(f.InfoCalls) == 1
}

// AssertInfoCalledOnce calls t.Error if Fakelogger.Info was not called exactly once
func (f *Fakelogger) AssertInfoCalledOnce(t loggerTestingT) {
	t.Helper()
	if len(f.InfoCalls) != 1 {
		t.Errorf("Fakelogger.Info called %d times, expected 1", len(f.InfoCalls))
	}
}

// InfoCalledN returns true if Fakelogger.Info was called at least n times
func (f *Fakelogger) InfoCalledN(n int) bool {
	return len(f.InfoCalls) >= n
}

// AssertInfoCalledN calls t.Error if Fakelogger.Info was called less than n times
func (f *Fakelogger) AssertInfoCalledN(t loggerTestingT, n int) {
	t.Helper()
	if len(f.InfoCalls) < n {
		t.Errorf("Fakelogger.Info called %d times, expected >= %d", len(f.InfoCalls), n)
	}
}

// InfoCalledWith returns true if Fakelogger.Info was called with the given values
func (f_sym14 *Fakelogger) InfoCalledWith(msg string) bool {
	for _, call_sym14 := range f_sym14.InfoCalls {
		if reflect.DeepEqual(call_sym14.Parameters.Msg, msg) {
			return true
		}
	}

	return false
}

// AssertInfoCalledWith calls t.Error if Fakelogger.Info was not called with the given values
func (f_sym15 *Fakelogger) AssertInfoCalledWith(t loggerTestingT, msg string) {
	t.Helper()
	var found_sym15 bool
	for _, call_sym15 := range f_sym15.InfoCalls {
		if reflect.DeepEqual(call_sym15.Parameters.Msg, msg) {
			found_sym15 = true
			break
		}
	}

	if !found_sym15 {
		t.Error("Fakelogger.Info not called with expected parameters")
	}
}

// InfoCalledOnceWith returns true if Fakelogger.Info was called exactly once with the given values
func (f_sym16 *Fakelogger) InfoCalledOnceWith(msg string) bool {
	var count_sym16 int
	for _, call_sym16 := range f_sym16.InfoCalls {
		if reflect.DeepEqual(call_sym16.Parameters.Msg, msg) {
			count_sym16++
		}
	}

	return count_sym16 == 1
}

// AssertInfoCalledOnceWith calls t.Error if Fakelogger.Info was not called exactly once with the given values
func (f_sym17 *Fakelogger) AssertInfoCalledOnceWith(t loggerTestingT, msg string) {
	t.Helper()
	var count_sym17 int
	for _, call_sym17 := range f_sym17.InfoCalls {
		if reflect.DeepEqual(call_sym17.Parameters.Msg, msg) {
			count_sym17++
		}
	}

	if count_sym17 != 1 {
		t.Errorf("Fakelogger.Info called %d times with expected parameters, expected one", count_sym17)
	}
}

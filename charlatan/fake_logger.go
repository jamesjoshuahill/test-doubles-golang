// generated by "charlatan -output=charlatan/fake_logger.go -package=charlatan logger".  DO NOT EDIT.

package charlatan

import "reflect"

// loggerInfoInvocation represents a single call of Fakelogger.Info
type loggerInfoInvocation struct {
	Parameters struct {
		Msg string
	}
}

// loggerTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type loggerTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
Fakelogger is a mock implementation of logger for testing.
Use it in your tests as in this example:

	package example

	func TestWithlogger(t *testing.T) {
		f := &charlatan.Fakelogger{
			InfoHook: func(msg string) () {
				// ensure parameters meet expectations, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeInfo ...
		f.AssertInfoCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeInfo.
*/
type Fakelogger struct {
	InfoHook func(string)

	InfoCalls []*loggerInfoInvocation
}

// NewFakeloggerDefaultPanic returns an instance of Fakelogger with all hooks configured to panic
func NewFakeloggerDefaultPanic() *Fakelogger {
	return &Fakelogger{
		InfoHook: func(string) {
			panic("Unexpected call to logger.Info")
		},
	}
}

// NewFakeloggerDefaultFatal returns an instance of Fakelogger with all hooks configured to call t.Fatal
func NewFakeloggerDefaultFatal(t_sym1 loggerTestingT) *Fakelogger {
	return &Fakelogger{
		InfoHook: func(string) {
			t_sym1.Fatal("Unexpected call to logger.Info")
			return
		},
	}
}

// NewFakeloggerDefaultError returns an instance of Fakelogger with all hooks configured to call t.Error
func NewFakeloggerDefaultError(t_sym2 loggerTestingT) *Fakelogger {
	return &Fakelogger{
		InfoHook: func(string) {
			t_sym2.Error("Unexpected call to logger.Info")
			return
		},
	}
}

func (f *Fakelogger) Reset() {
	f.InfoCalls = []*loggerInfoInvocation{}
}

func (f_sym3 *Fakelogger) Info(msg string) {
	if f_sym3.InfoHook == nil {
		panic("logger.Info() called but Fakelogger.InfoHook is nil")
	}

	invocation_sym3 := new(loggerInfoInvocation)
	f_sym3.InfoCalls = append(f_sym3.InfoCalls, invocation_sym3)

	invocation_sym3.Parameters.Msg = msg

	f_sym3.InfoHook(msg)

	return
}

// InfoCalled returns true if Fakelogger.Info was called
func (f *Fakelogger) InfoCalled() bool {
	return len(f.InfoCalls) != 0
}

// AssertInfoCalled calls t.Error if Fakelogger.Info was not called
func (f *Fakelogger) AssertInfoCalled(t loggerTestingT) {
	t.Helper()
	if len(f.InfoCalls) == 0 {
		t.Error("Fakelogger.Info not called, expected at least one")
	}
}

// InfoNotCalled returns true if Fakelogger.Info was not called
func (f *Fakelogger) InfoNotCalled() bool {
	return len(f.InfoCalls) == 0
}

// AssertInfoNotCalled calls t.Error if Fakelogger.Info was called
func (f *Fakelogger) AssertInfoNotCalled(t loggerTestingT) {
	t.Helper()
	if len(f.InfoCalls) != 0 {
		t.Error("Fakelogger.Info called, expected none")
	}
}

// InfoCalledOnce returns true if Fakelogger.Info was called exactly once
func (f *Fakelogger) InfoCalledOnce() bool {
	return len(f.InfoCalls) == 1
}

// AssertInfoCalledOnce calls t.Error if Fakelogger.Info was not called exactly once
func (f *Fakelogger) AssertInfoCalledOnce(t loggerTestingT) {
	t.Helper()
	if len(f.InfoCalls) != 1 {
		t.Errorf("Fakelogger.Info called %d times, expected 1", len(f.InfoCalls))
	}
}

// InfoCalledN returns true if Fakelogger.Info was called at least n times
func (f *Fakelogger) InfoCalledN(n int) bool {
	return len(f.InfoCalls) >= n
}

// AssertInfoCalledN calls t.Error if Fakelogger.Info was called less than n times
func (f *Fakelogger) AssertInfoCalledN(t loggerTestingT, n int) {
	t.Helper()
	if len(f.InfoCalls) < n {
		t.Errorf("Fakelogger.Info called %d times, expected >= %d", len(f.InfoCalls), n)
	}
}

// InfoCalledWith returns true if Fakelogger.Info was called with the given values
func (f_sym4 *Fakelogger) InfoCalledWith(msg string) bool {
	for _, call_sym4 := range f_sym4.InfoCalls {
		if reflect.DeepEqual(call_sym4.Parameters.Msg, msg) {
			return true
		}
	}

	return false
}

// AssertInfoCalledWith calls t.Error if Fakelogger.Info was not called with the given values
func (f_sym5 *Fakelogger) AssertInfoCalledWith(t loggerTestingT, msg string) {
	t.Helper()
	var found_sym5 bool
	for _, call_sym5 := range f_sym5.InfoCalls {
		if reflect.DeepEqual(call_sym5.Parameters.Msg, msg) {
			found_sym5 = true
			break
		}
	}

	if !found_sym5 {
		t.Error("Fakelogger.Info not called with expected parameters")
	}
}

// InfoCalledOnceWith returns true if Fakelogger.Info was called exactly once with the given values
func (f_sym6 *Fakelogger) InfoCalledOnceWith(msg string) bool {
	var count_sym6 int
	for _, call_sym6 := range f_sym6.InfoCalls {
		if reflect.DeepEqual(call_sym6.Parameters.Msg, msg) {
			count_sym6++
		}
	}

	return count_sym6 == 1
}

// AssertInfoCalledOnceWith calls t.Error if Fakelogger.Info was not called exactly once with the given values
func (f_sym7 *Fakelogger) AssertInfoCalledOnceWith(t loggerTestingT, msg string) {
	t.Helper()
	var count_sym7 int
	for _, call_sym7 := range f_sym7.InfoCalls {
		if reflect.DeepEqual(call_sym7.Parameters.Msg, msg) {
			count_sym7++
		}
	}

	if count_sym7 != 1 {
		t.Errorf("Fakelogger.Info called %d times with expected parameters, expected one", count_sym7)
	}
}
